# -*- coding: utf-8 -*-
"""improved_quantum_com1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b0wLQjlilCRN6mVshUnedHjikmpSRRMr
"""

import numpy as np

def pushQubit(name,weights):
    global workspace
    global namestack
    if workspace.shape == (1,1):                  # if workspace empty
        namestack = []                            # then reset
    namestack.append(name)                        # push name
    weights = weights/np.linalg.norm(weights)     # normalize
    weights = np.array(weights,dtype=workspace[0,0].dtype)
    workspace = np.reshape(workspace,(1,-1))      # to row vector
    workspace = np.kron(workspace,weights)

def tosQubit(name):
  global workspace
  global namestack
  k = len(namestack)-namestack.index(name)    # qubit pos
  if k > 1:                                   # if non-trivial
    namestack.append(namestack.pop(-k))         # rotate name stack
    workspace = np.reshape(workspace,(-1,2,2**(k-1)))
    workspace = np.swapaxes(workspace,-2,-1)

def applyGate(gate,*names):
    global workspace
    if list(names) != namestack[-len(names):]: # reorder stack
        for name in names: # if necessary
            tosQubit(name)
    workspace = np.reshape(workspace,(-1,2**(len(names))))
    subworkspace = workspace[:,-gate.shape[0]:]
    np.matmul(subworkspace,gate.T,out=subworkspace)

X_gate = np.array([[0, 1],                      # Pauli X gate
                   [1, 0]])                     # = NOT gate

Y_gate = np.array([[ 0,-1j],                    # Pauli Y gate
                   [1j,  0]])                   # = SHZHZS

Z_gate = np.array([[1, 0],                      # Pauli Z gate
                   [0,-1]])                     # = P(pi) = S^2
                                                # = HXH

H_gate = np.array([[1, 1],                      # Hadamard gate
                   [1,-1]]) * np.sqrt(1/2)

S_gate = np.array([[1, 0],                      # Phase gate
                   [0,1j]])                     # = P(pi/2) = T^2

T_gate = np.array([[1,                0],       # = P(pi/4)
                   [0,np.exp(np.pi/-4j)]])

Tinv_gate = np.array([[1, 0],                   # = P(-pi/4)
                      [0,np.exp(np.pi/4j)]])    # = T^-1

def P_gate(phi):                                # Phase shift gate
    return np.array([[1,             0],
                     [0,np.exp(phi*1j)]])

def Rx_gate(theta):                             # Y rotation gate
    return np.array([[np.cos(theta/2),-1j*np.sin(theta/2)],
                     [-1j*np.sin(theta/2),np.cos(theta/2)]])

def Ry_gate(theta):                             # Y rotation gate return
    np.array([[np.cos(theta/2),-np.sin(theta/2)],
              [np.sin(theta/2), np.cos(theta/2)]])

def Rz_gate(theta):                             # Z rotation gate
    return np.array([[np.exp(-1j*theta/2),                0],
                     [                  0,np.exp(1j*theta/2)]])

CNOT_gate = np.array([[1, 0, 0, 0],             # Ctled NOT gate
                      [0, 1, 0, 0],             #=XORgate
                      [0, 0, 0, 1],
                      [0, 0, 1, 0]])

CZ_gate = np.array([[1, 0, 0, 0],               # Ctled Z gate
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0,-1]])

SWAP_gate = np.array([[1, 0, 0, 0],             # Swap gate
                      [0, 0, 1, 0],
                      [0, 1, 0, 0],
                      [0, 0, 0, 1]])

TOFF_gate = np.array([[1, 0, 0, 0, 0, 0, 0, 0], # Toffoli gate
                     [0, 1, 0, 0, 0, 0, 0, 0],
                     [0, 0, 1, 0, 0, 0, 0, 0],
                     [0, 0, 0, 1, 0, 0, 0, 0],
                     [0, 0, 0, 0, 1, 0, 0, 0],
                     [0, 0, 0, 0, 0, 1, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 1],
                     [0, 0, 0, 0, 0, 0, 1, 0]])

def probQubit(name):
    global workspace
    tosQubit(name)
    workspace = np.reshape(workspace,(-1,2))
    prob = np.linalg.norm(workspace,axis=0)**2
    return prob/prob.sum()                 # make sure sum is one

def measureQubit(name):
    global workspace
    global namestack
    prob = probQubit(name)
    measurement = np.random.choice(2,p=prob)
    workspace = (workspace[:,[measurement]]/
                 np.sqrt(prob[measurement]))
    namestack.pop()
    return str(measurement)

workspace = np.array([[1.]])        # create empty qubit stack
pushQubit("Q1",[1,1])               # push a qubit
print(np.reshape(workspace,(1,-1))) # print workspace as vector print(namestack)
pushQubit("Q2",[0,1])               # push a 2nd qubit
print(np.reshape(workspace,(1,-1))) # print workspace as vector print(namestack)
print(np.reshape(workspace,(1,-1)))  # print workspace as vector
print(namestack)
tosQubit("Q1")                       # swap qubits
print(np.reshape(workspace,(1,-1)))  # print workspace as vector print(namestack)
print(np.reshape(workspace,(1,-1)))       # print workspace as vector
print(namestack)
applyGate(H_gate,"Q2")                    # H gate on qubit 2
print(np.reshape(workspace,(1,-1)))       # turns a 0 qubit to 1
print(namestack)                          # with 50% probability

def TOFF3_gate(q1,q2,q3,q4):
    applyGate(X_gate,q1,q2,q3,q4)

def TOFFn_gate(ctl,result):
    applyGate(X_gate,*ctl,result)

workspace = np.array([[1]],dtype=np.single)
for i in range(20):
    pushQubit("Q1",[1,1])
    pushQubit("Q2",[1,1])
    pushQubit("Q3",[1,1])
    pushQubit("Q4",[1,0])

    TOFF3_gate("Q1","Q2","Q3","Q4")
    print("".join([measureQubit(q) for q in
          ["Q1","Q2","Q3","Q4"]]),end="/")
    pushQubit("Q1",[1,1])
    pushQubit("Q2",[1,1])
    pushQubit("Q3",[1,1])
    pushQubit("Q4",[1,0])
    TOFFn_gate(["Q1","Q2","Q3"],"Q4")
    print("".join([measureQubit(q) for q in
          ["Q1","Q2","Q3","Q4"]]),end=",")